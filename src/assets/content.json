{
  "categories": {
    "architecture": {
      "title": "Architecture",
      "summary": "This category summarizes best practices regarding architecture.",
      "slug": "architecture",
      "items": [
        "Z1JIVG3",
        "Z1xqb2O",
        "Z11LOp2",
        "Z24l73x"
      ]
    },
    "ngrx": {
      "title": "NgRx",
      "summary": "This category summarizes best practices regarding NgRx.",
      "slug": "ngrx",
      "items": [
        "2sJuJG"
      ]
    },
    "performance": {
      "title": "Performance",
      "summary": "This category contains a list of practices which will help us boost the performance of our Angular applications. It covers different topics - from server-side pre-rendering and bundling of our applications, to runtime performance and optimization of the change detection performed by the framework.",
      "slug": "performance",
      "items": [
        "Z8rHxb",
        "ZDAf5h",
        "AvD9O"
      ]
    },
    "rxjs": {
      "title": "RxJS",
      "summary": "This category summarizes best practices regarding RxJS.",
      "slug": "rxjs",
      "items": [
        "bkHEY",
        "ZzpwmT",
        "ZHuJoA",
        "ZBbo7y"
      ]
    }
  },
  "items": {
    "Z1JIVG3": {
      "id": "Z1JIVG3",
      "slug": "business-logic",
      "title": "Business logic in services",
      "content": "<h3>Business logic in services</h3>\n<p>All the business logic in the application is moved to services. Smart components (TOOD: link to the smart vs dumb components) can only hold logic that is related to this specific component. All the business logic access to backend resources should be abstracted to services.</p>\n"
    },
    "Z1xqb2O": {
      "id": "Z1xqb2O",
      "slug": "folder-structure",
      "title": "Folder Structure",
      "content": "<h3>Folder Structure</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-function\">(<span class=\"hljs-params\">bar: <span class=\"hljs-built_in\">string</span></span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> bar;\n};\n</code></pre>\n"
    },
    "Z11LOp2": {
      "id": "Z11LOp2",
      "slug": "modules",
      "title": "Modules and services",
      "content": "<h3>Providing the services only at the root level</h3>\n<p>Every time a service is provided at a different level (component, module), an instance will be created when something inside that module or that component asks for an instance of it. Whilst this can be what you want, it is in most cases not the expected behaviour.</p>\n<p>When you are creating a <code>SharedModule</code>, you want to use the components everywhere but only provide the services at the <code>AppModule</code> level. You can accomplish this by defining your <code>SharedModule</code> like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [...modules],\n  declarations: [...declarations],\n  exports: [...declarations]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SharedModule {\n  <span class=\"hljs-keyword\">static</span> forRoot() {\n    <span class=\"hljs-keyword\">return</span> {\n      ngModule: SharedModule,\n      providers: [...services]\n    };\n  }\n</code></pre>\n<p>In your <code>AppModule</code>, you could use this module like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [\n  \t...modules,\n  \tSharedModule.forRoot()\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppModule {}\n</code></pre>\n<p>Thus, also providing the <code>providers</code> section.</p>\n<p>In a feature module where the services are not required, you could use the <code>SharedModule</code> like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [\n  \t...modules,\n  \tSharedModule\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeFeature {}\n</code></pre>\n<p>Thus, having access to all the components, pipes, … provided by the <code>SharedModule</code> without creating multiple instances of a service.</p>\n"
    },
    "Z24l73x": {
      "id": "Z24l73x",
      "slug": "smart-and-dumb-components",
      "title": "Smart and dumb components",
      "content": "<h3>Smart and Dumb Components</h3>\n<p>Every major frontend framework nowadays is moving towards a component based architecture. Components are a combination of a little bit of html, javascript and css. This way of working can provide us with a lot of benefits if used in the correct way.</p>\n<p>The most advocated way to use them is through smart and dumb components (there is a variety of other names as well but the general principle is the same).</p>\n<h4>Component types</h4>\n<p>A dumb component:</p>\n<ul>\n<li>Gets data through <code>@Input</code>s and communicates only with it’s direct parent through <code>@Output</code>s.</li>\n<li>It does not know about the rest of the application. It is dumb and does not know where it is being used.</li>\n<li>Can contain business logic, but only logic that belongs to the scope of this component. A paging component can contain the logic to calculate the number of ‘boxes’ to show. It does not know what happens when a user clicks a page number. In that case, it throws a custom events to tell the page is clicked and the parent component decides what happens.</li>\n<li>It can use other dumb components as children.</li>\n<li>It can inject services that are related to the view layer of your application (think <code>TranslateService</code>, <code>Router</code>, …) but never services to fetch its own data.</li>\n</ul>\n<p>A smart component:</p>\n<ul>\n<li>Knows about the application and will fetch data.</li>\n<li>It passes data down to dumb components as much as possible and mostly only contains the business logic to fetch the data.</li>\n<li>It is build up out of several dumb components.</li>\n<li>It listen for events thrown by the dumb components and performs the required action for them.</li>\n</ul>\n<h4>Benefits</h4>\n<ul>\n<li>Dumb components are completely reusable since they have a defined API and are not linked to any specific services of data calls.</li>\n<li>Dumb components are easy to test as they are completely isolated.</li>\n<li>The entire architecture of your components becomes easier to reason about. If there is a business logic or data fetching problem, you know that you need to start searching in the smart component. Since that is the responsability of that component.</li>\n</ul>\n<h4>External resources</h4>\n<ul>\n<li><a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\" target=\"_blank\">Presentational and container components</a> by Dan Abramov.</li>\n<li><a href=\"https://blog.angular-university.io/angular-2-smart-components-vs-presentation-components-whats-the-difference-when-to-use-each-and-why/\" target=\"_blank\">Smart components vs Presentational components</a> by angular University.</li>\n<li><a href=\"https://blog.strongbrew.io/the-smart-vs-dumb-components-quiz/\" target=\"_blank\">The smart vs dumb component quiz</a> by Kwinten Pisman.</li>\n</ul>\n"
    },
    "2sJuJG": {
      "id": "2sJuJG",
      "slug": "not-everything-in-the-store",
      "title": "Not everything is in the store",
      "content": "<h1>Not everything is in the store</h1>\n<p>NgRx/Store (or Redux in general) provides us with a lot of great features and can be used in a lot of use cases. In some cases however, this pattern can be overkill and should be avoided. As a general rule of thumb, the following listing will help you to know when it helps to put data into the store.</p>\n<ul>\n<li>When data is shared between components that are in totally different places in the component tree. By putting this data into the store, it is easier to consume this data in those components.</li>\n<li>State that needs to be hydrated between page reloads. If you want your component to look the same way as it did before it was destroyed.</li>\n<li>State that can be updated from multiple places. Let’s say you have a list of users which can be updated through crud operations. In that case it is easier to manage this by putting this data into the store.</li>\n</ul>\n<p>This is a non exhausitve listing and there will always be exceptions to the rule. In most cases however, keeping to data that complies with one or more points in this list, is a good idea.</p>\n<p>In the following cases, using Redux might NOT be the best idea.</p>\n<ul>\n<li>When caching data from a backend call. If you want to cache data coming from a backend call, you can easily accomplish this by keeping a reference to the <code>Observable</code> from the <code>HttpClient</code> and adding a <code>shareReplay(1)</code> operator to it. This operator will cache the underlying result of the backend call and return it to every subsequent subscriber without re-executing it.</li>\n<li>When state is only needed for the lifecyle of the component. In cases where the data is added to the store, just to be removed on the <code>ngOnDestroy</code> lifecycle hook, it doens’t have any benefits.</li>\n</ul>\n"
    },
    "Z8rHxb": {
      "id": "Z8rHxb",
      "slug": "bundling",
      "title": "Bundling",
      "source": "https://github.com/mgechev/angular-performance-checklist",
      "author": {
        "name": "Minko Gechev",
        "url": "https://twitter.com/mgechev"
      },
      "content": "<h3>Bundling</h3>\n<p>Bundling is a standard practice aiming to reduce the number of requests that the browser needs to perform in order to deliver the application requested by the user. In essence, the bundler receives as an input a list of entry points and produces one or more bundles. This way, the browser can get the entire application by performing only a few requests, instead of requesting each individual resource separately.</p>\n<p>As your application grows bundling everything into a single large bundle would again be counter productive. Explore Code Splitting techniques using Webpack.</p>\n<p><strong>Additional http requests will not be a concern with HTTP/2 because of the server push feature.</strong></p>\n<h4>Tooling</h4>\n<p>Tools which allows us to bundle our applications efficiently are:</p>\n<ul>\n<li><a href=\"https://github.com/angular/angular-cli\">Angular CLI</a> - A command line interface for Angular which makes it easy to create an application that already works, right out of the box. It already follows many best practices and focuses on performance.</li>\n<li><a href=\"https://webpack.js.org\">Webpack</a> - provides efficient bundling by performing <a href=\"#tree-shaking\">tree-shaking</a>.</li>\n<li><a href=\"https://webpack.js.org/guides/code-splitting/\">Webpack Code Splitting</a> - Techniques to split your code.</li>\n<li><a href=\"https://medium.com/webpack/webpack-http-2-7083ec3f3ce6#.46idrz8kb\">Webpack &amp; http2</a> - Need for splitting with http2.</li>\n<li><a href=\"https://github.com/rollup/rollup\">Rollup</a> - provides bundling by performing efficient tree-shaking, taking advantage of the static nature of the ES2015 modules.</li>\n<li><a href=\"https://github.com/google/closure-compiler\">Google Closure Compiler</a> - performs plenty of optimizations and provides bundling support. Originally written in Java, since recently it also has a <a href=\"https://www.npmjs.com/package/google-closure-compiler-js\">JavaScript version</a> which can be <a href=\"https://www.npmjs.com/package/google-closure-compiler-js\">found here</a>.</li>\n<li><a href=\"https://github.com/systemjs/builder\">SystemJS Builder</a> - provides a single-file build for SystemJS of mixed-dependency module trees.</li>\n<li><a href=\"http://browserify.org/\">Browserify</a>.</li>\n</ul>\n"
    },
    "ZDAf5h": {
      "id": "ZDAf5h",
      "slug": "onpush",
      "title": "Bundling",
      "source": "https://github.com/mgechev/angular-performance-checklist",
      "author": {
        "name": "Minko Gechev",
        "url": "https://twitter.com/mgechev"
      },
      "content": "<h3>Bundling</h3>\n<p>Bundling is a standard practice aiming to reduce the number of requests that the browser needs to perform in order to deliver the application requested by the user. In essence, the bundler receives as an input a list of entry points and produces one or more bundles. This way, the browser can get the entire application by performing only a few requests, instead of requesting each individual resource separately.</p>\n<p>As your application grows bundling everything into a single large bundle would again be counter productive. Explore Code Splitting techniques using Webpack.</p>\n<p><strong>Additional http requests will not be a concern with HTTP/2 because of the server push feature.</strong></p>\n<h4>Tooling</h4>\n<p>Tools which allows us to bundle our applications efficiently are:</p>\n<ul>\n<li><a href=\"https://github.com/angular/angular-cli\">Angular CLI</a> - A command line interface for Angular which makes it easy to create an application that already works, right out of the box. It already follows many best practices and focuses on performance.</li>\n<li><a href=\"https://webpack.js.org\">Webpack</a> - provides efficient bundling by performing <a href=\"#tree-shaking\">tree-shaking</a>.</li>\n<li><a href=\"https://webpack.js.org/guides/code-splitting/\">Webpack Code Splitting</a> - Techniques to split your code.</li>\n<li><a href=\"https://medium.com/webpack/webpack-http-2-7083ec3f3ce6#.46idrz8kb\">Webpack &amp; http2</a> - Need for splitting with http2.</li>\n<li><a href=\"https://github.com/rollup/rollup\">Rollup</a> - provides bundling by performing efficient tree-shaking, taking advantage of the static nature of the ES2015 modules.</li>\n<li><a href=\"https://github.com/google/closure-compiler\">Google Closure Compiler</a> - performs plenty of optimizations and provides bundling support. Originally written in Java, since recently it also has a <a href=\"https://www.npmjs.com/package/google-closure-compiler-js\">JavaScript version</a> which can be <a href=\"https://www.npmjs.com/package/google-closure-compiler-js\">found here</a>.</li>\n<li><a href=\"https://github.com/systemjs/builder\">SystemJS Builder</a> - provides a single-file build for SystemJS of mixed-dependency module trees.</li>\n<li><a href=\"http://browserify.org/\">Browserify</a>.</li>\n</ul>\n"
    },
    "AvD9O": {
      "id": "AvD9O",
      "slug": "template-whitespace",
      "title": "Remove Template Whitespace",
      "source": "https://github.com/mgechev/angular-performance-checklist",
      "author": {
        "name": "Minko Gechev",
        "url": "https://twitter.com/mgechev"
      },
      "content": "<h3>Remove Template Whitespace</h3>\n<p>Although we don’t see the whitespace character (a character matching the <code>\\s</code> regex) it is still represented by bytes which are transfered over the network. If we reduce the whitespace from our templates to minimum we will be respectively able to drop the bundle size of the AoT code even further.</p>\n<p>Thankfully, we don’t have to do this manually. The <code>ComponentMetadata</code> interface provides the property <code>preserveWhitespaces</code> which by default has value <code>true</code>, because removing the whitespace always may influence the DOM layout. In case we set the property to <code>false</code> Angular will trim the unnecessary whitespace which will lead to further reduction of the bundle size.</p>\n<ul>\n<li><a href=\"https://angular.io/api/core/Component#preserveWhitespaces\">preserveWhitespaces in the Angular docs</a></li>\n</ul>\n"
    },
    "bkHEY": {
      "id": "bkHEY",
      "slug": "caching",
      "title": "Caching",
      "content": "<h1>Caching</h1>\n"
    },
    "ZzpwmT": {
      "id": "ZzpwmT",
      "slug": "pipeable-operators",
      "title": "Pipeable Operators",
      "content": "<h3>Pipeable Operators</h3>\n"
    },
    "ZHuJoA": {
      "id": "ZHuJoA",
      "slug": "subjects",
      "title": "Subjects",
      "content": "<h3>Subjects</h3>\n"
    },
    "ZBbo7y": {
      "id": "ZBbo7y",
      "slug": "subscriptions",
      "title": "Subscriptions",
      "content": "<h3>Subscriptions</h3>\n"
    }
  }
}