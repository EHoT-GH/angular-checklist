{
  "categories": {
    "architecture": {
      "title": "Architecture",
      "summary": "This category summarizes best practices regarding architecture.",
      "slug": "architecture",
      "items": [
        "Z1uCcrx",
        "l2hnF",
        "Z1xqb2O",
        "opRwV",
        "Z24l73x"
      ]
    },
    "ngrx": {
      "title": "NgRx",
      "summary": "This category summarizes best practices regarding NgRx.",
      "slug": "ngrx",
      "items": [
        "4gz6q",
        "2sJuJG"
      ]
    },
    "performance": {
      "title": "Performance",
      "summary": "This category contains a list of practices which will help us boost the performance of our Angular applications. It covers different topics - from server-side pre-rendering and bundling of our applications, to runtime performance and optimization of the change detection performed by the framework.",
      "slug": "performance",
      "items": [
        "Z8rHxb",
        "Z13mvQ4",
        "iOnTI",
        "AvD9O"
      ]
    },
    "router": {
      "title": "Router",
      "summary": "This category summarizes best practices regarding routing.",
      "slug": "router",
      "items": [
        "PaBkH",
        "5ScV4",
        "iOnTI",
        "Z1WXxTy"
      ]
    },
    "rxjs": {
      "title": "RxJS",
      "summary": "This category summarizes best practices regarding RxJS.",
      "slug": "rxjs",
      "items": [
        "bkHEY",
        "ZzpwmT",
        "ZHuJoA",
        "ZBbo7y"
      ]
    }
  },
  "items": {
    "Z1uCcrx": {
      "id": "Z1uCcrx",
      "slug": "business-logic-in-services",
      "title": "Business Logic in Services",
      "content": "<h3>Business Logic in Services</h3>\n<p>All business logic in the application is moved into services. Smart components (TODO: link to the smart vs dumb components) should only contain logic that is related to this specific component. For example business logic that is used to access backend resources should be abstracted into services.</p>\n"
    },
    "l2hnF": {
      "id": "l2hnF",
      "slug": "file-naming",
      "title": "File Naming",
      "content": "<h3>Separate file names with dots and dashes</h3>\n<p>It is recommended to separate words with dashes and dots to separate the descriptive name from the type. The descriptive name of a file should describe the component’s feature.</p>\n<p>Also, try to use conventional suffix that describe the type of the file, e.g. <code>.component.ts</code>, <code>.directive.ts</code>, <code>.service.ts</code>, <code>.module.ts</code>, <code>.pipe.ts</code>.</p>\n<p>Here are a few examples:</p>\n<ul>\n<li><code>app.component.ts</code></li>\n<li><code>contacts.service.ts</code></li>\n<li><code>product-list.component.ts</code></li>\n</ul>\n<p>Using such naming convention helps to provide a consistant way to find content very quickly and easily. Consistancy will save you time and make you and your team more efficient.</p>\n<h3>Use the name and type of the file for your class names</h3>\n<p>If the file you are working on is <code>app.component.ts</code> it is obvious that this must be a component. It also tells us the name of this component, which is <code>app</code>. This means we’d call our class <code>AppComponent</code>:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({ ... })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppComponent { }\n</code></pre>\n<p>Here’s another example of a class defined in <code>product-list.component.ts</code>:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({ ... })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> ProductListComponent { }\n</code></pre>\n"
    },
    "Z1xqb2O": {
      "id": "Z1xqb2O",
      "slug": "folder-structure",
      "title": "Folder Structure",
      "content": "<h3>Folder Structure</h3>\n"
    },
    "opRwV": {
      "id": "opRwV",
      "slug": "modules-and-services",
      "title": "Modules and Services",
      "content": "<h3>Providing services only at the root level</h3>\n<p>In Angular we have the possibility to take advantage of the injector tree to provide different service instances on different levels, e.g. component, directive or module. Whilst this can be exactly what you want, in most cases it is not the expected behavior.</p>\n<p>When you are creating a <code>SharedModule</code>, you want to use the components everywhere but only provide the services in your root module, e.g. <code>AppModule</code>. You can accomplish this by leveraging the <code>forRoot</code> convention. Your <code>SharedModule</code> would then like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [...modules],\n  declarations: [...declarations],\n  exports: [...declarations]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SharedModule {\n  <span class=\"hljs-keyword\">static</span> forRoot(): ModuleWithProviders {\n    <span class=\"hljs-keyword\">return</span> {\n      ngModule: SharedModule,\n      providers: [...services]\n    };\n  }\n</code></pre>\n<p>Note that the actual module definion <strong>does not</strong> contain any providers.</p>\n<p>In your <code>AppModule</code>, you could use this module as follows:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [\n    ...modules,\n    SharedModule.forRoot()\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppModule {}\n</code></pre>\n<p>By calling the static <code>forRoot</code> method on the <code>SharedModule</code> you will import the entire module <strong>including</strong> its providers.</p>\n<p>In a feature module you would simply import the <code>SharedModule</code> <strong>without</strong> calling <code>forRoot</code>:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [\n    ...modules,\n    SharedModule\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeFeature {}\n</code></pre>\n<p>The fact that each component has its own Injector that is inherited from its parent Injector, allows us to ask for services provided at a root level. Hence, we have access to all the components, pipes, etc. provided by the <code>SharedModule</code> without creating multiple instances of its services.</p>\n<h3>Additional Resources</h3>\n<ul>\n<li><a href=\"https://blog.thoughtram.io/angular/2015/05/18/dependency-injection-in-angular-2.html\">Dependency Injection in Angular</a> by Pascal Precht</li>\n<li><a href=\"https://blog.thoughtram.io/angular/2016/09/14/bypassing-providers-in-angular-2.html\">Bypassing Providers in Angular</a> by Pascal Precht</li>\n<li><a href=\"https://blog.angularindepth.com/avoiding-common-confusions-with-modules-in-angular-ada070e6891f\">Avoiding common confusions with modules in Angular</a> by Maxim Koretskyi</li>\n</ul>\n"
    },
    "Z24l73x": {
      "id": "Z24l73x",
      "slug": "smart-and-dumb-components",
      "title": "Smart and Dumb Components",
      "content": "<h3>Smart and Dumb Components</h3>\n<p>Every major frontend framework nowadays is moving towards a component-based architecture. Components are a combination of a little bit of HTML, JavaScript and CSS. This way of working can provide us with a lot of benefits if used in the correct way.</p>\n<p>The most advocated way to use them is through smart and dumb components (there is a variety of other names as well but the general principle is the same).</p>\n<h3>Component Types</h3>\n<p><strong>Dumb Component</strong>:</p>\n<ul>\n<li>Receives data through <code>@Input</code>s and communicates only with it’s direct parent through <code>@Output</code>s.</li>\n<li>Dumb components should not receive <code>Observables</code> as inputs</li>\n<li>It does not know about the rest of the application. It is dumb and does not know where it is being used.</li>\n<li>Can contain business logic, but only logic that belongs to the scope of this component. For example, a pagination component can contain logic to calculate the number of ‘boxes’ to show. It does not know what happens when a user clicks a page number. In that case, it throws a custom event to notify its parent the that something has happened. The parent component then decides what happens.</li>\n<li>It can use other dumb components as children.</li>\n<li>It can inject services that are related to the view layer of your application (think <code>TranslateService</code>, <code>Router</code>, …) but never services to fetch its own data.</li>\n</ul>\n<p><strong>Smart Component</strong>:</p>\n<ul>\n<li>Knows about the application and will fetch data.</li>\n<li>It passes data down to dumb components as much as possible and mostly only contains the business logic to fetch the data.</li>\n<li>It is build up out of several dumb components.</li>\n<li>It listen for events thrown by the dumb components and performs the required action for them.</li>\n</ul>\n<h3>Benefits</h3>\n<ul>\n<li>Dumb components are completely reusable since they have a defined API and are independet of any buiness logic.</li>\n<li>Dumb components are easy to test as they are completely isolated.</li>\n<li>The entire architecture of your components becomes easier to reason about. If there is a business logic or data fetching problem, you know that you need to start searching in your smart components since this is the responsability of that component.</li>\n</ul>\n<h3>External Resources</h3>\n<ul>\n<li><a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\">Presentational and container components</a> by Dan Abramov.</li>\n<li><a href=\"https://blog.angular-university.io/angular-2-smart-components-vs-presentation-components-whats-the-difference-when-to-use-each-and-why/\">Smart components vs Presentational components</a> by Angular University.</li>\n<li><a href=\"https://blog.strongbrew.io/the-smart-vs-dumb-components-quiz/\">The smart vs dumb component quiz</a> by Kwinten Pisman.</li>\n</ul>\n"
    },
    "4gz6q": {
      "id": "4gz6q",
      "slug": "big-lists-are-normalised",
      "title": "Big lists are normalised",
      "content": "<h3>Big lists are normalised</h3>\n<p>The easiest way to store data into the store is through arrays. When you perform a backend call, you probably get an array back as a result anyway and you can just add this to the store.\nThe big downside to this approach is that, if you want to for example remove an element from the array, you first have to find the element before you can remove it. This means that the big O notation of finding an element like that is O(n). While for smaller lists, this might not be a problem, but as list get bigger and bigger and the number of interactions on this list</p>\n"
    },
    "2sJuJG": {
      "id": "2sJuJG",
      "slug": "not-everything-in-the-store",
      "title": "Not everything is in the store",
      "content": "<h3>Not everything is in the store</h3>\n<p>NgRx/Store (or Redux in general) provides us with a lot of great features and can be used in a lot of use cases. In some cases however, this pattern can be overkill and should be avoided. As a general rule of thumb, the following listing will help you to know when it helps to put data into the store.</p>\n<ul>\n<li>When data is shared between components that are in totally different places in the component tree. By putting this data into the store, it is easier to consume this data in those components.</li>\n<li>State that needs to be hydrated between page reloads. If you want your component to look the same way as it did before it was destroyed.</li>\n<li>State that can be updated from multiple places. Let’s say you have a list of users which can be updated through crud operations. In that case it is easier to manage this by putting this data into the store.</li>\n</ul>\n<p>This is a non exhausitve listing and there will always be exceptions to the rule. In most cases however, keeping to data that complies with one or more points in this list, is a good idea.</p>\n<p>In the following cases, using Redux might NOT be the best idea.</p>\n<ul>\n<li>When caching data from a backend call. If you want to cache data coming from a backend call, you can easily accomplish this by keeping a reference to the <code>Observable</code> from the <code>HttpClient</code> and adding a <code>shareReplay(1)</code> operator to it. This operator will cache the underlying result of the backend call and return it to every subsequent subscriber without re-executing it.</li>\n<li>When state is only needed for the lifecyle of the component. In cases where the data is added to the store, just to be removed on the <code>ngOnDestroy</code> lifecycle hook, it doens’t have any benefits.</li>\n</ul>\n"
    },
    "Z8rHxb": {
      "id": "Z8rHxb",
      "slug": "bundling",
      "title": "Bundling",
      "source": "https://github.com/mgechev/angular-performance-checklist",
      "author": {
        "name": "Minko Gechev",
        "url": "https://twitter.com/mgechev"
      },
      "content": "<h3>Bundling</h3>\n<p>Bundling is a standard practice aiming to reduce the number of requests that the browser needs to perform in order to deliver the application requested by the user. In essence, the bundler receives as an input a list of entry points and produces one or more bundles. This way, the browser can get the entire application by performing only a few requests, instead of requesting each individual resource separately.</p>\n<p>As your application grows bundling everything into a single large bundle would again be counter productive. Explore Code Splitting techniques using Webpack.</p>\n<p><strong>Additional http requests will not be a concern with HTTP/2 because of the server push feature.</strong></p>\n<h4>Tooling</h4>\n<p>Tools which allows us to bundle our applications efficiently are:</p>\n<ul>\n<li><a href=\"https://github.com/angular/angular-cli\">Angular CLI</a> - A command line interface for Angular which makes it easy to create an application that already works, right out of the box. It already follows many best practices and focuses on performance.</li>\n<li><a href=\"https://webpack.js.org\">Webpack</a> - provides efficient bundling by performing <a href=\"#tree-shaking\">tree-shaking</a>.</li>\n<li><a href=\"https://webpack.js.org/guides/code-splitting/\">Webpack Code Splitting</a> - Techniques to split your code.</li>\n<li><a href=\"https://medium.com/webpack/webpack-http-2-7083ec3f3ce6#.46idrz8kb\">Webpack &amp; http2</a> - Need for splitting with http2.</li>\n<li><a href=\"https://github.com/rollup/rollup\">Rollup</a> - provides bundling by performing efficient tree-shaking, taking advantage of the static nature of the ES2015 modules.</li>\n<li><a href=\"https://github.com/google/closure-compiler\">Google Closure Compiler</a> - performs plenty of optimizations and provides bundling support. Originally written in Java, since recently it also has a <a href=\"https://www.npmjs.com/package/google-closure-compiler-js\">JavaScript version</a> which can be <a href=\"https://www.npmjs.com/package/google-closure-compiler-js\">found here</a>.</li>\n<li><a href=\"https://github.com/systemjs/builder\">SystemJS Builder</a> - provides a single-file build for SystemJS of mixed-dependency module trees.</li>\n<li><a href=\"http://browserify.org/\">Browserify</a>.</li>\n</ul>\n"
    },
    "Z13mvQ4": {
      "id": "Z13mvQ4",
      "slug": "change-detection-optimization",
      "title": "ChangeDetection Optimization",
      "content": "<h3>Using OnPush</h3>\n"
    },
    "iOnTI": {
      "id": "iOnTI",
      "slug": "lazy-loading",
      "title": "Lazy loading",
      "content": "<h3>Lazy loading modules</h3>\n<p>Angular is using a modular architecture. This allows us to split the application into different modules. When using the Angular CLI, it becomes really easy to lazy load these modules via our route definitions.</p>\n<pre class=\"hljs\"><code>[\n  { path: <span class=\"hljs-string\">'/heroes'</span>, loadChildren: <span class=\"hljs-string\">'app/heroes/heroes.module#HeroesModule'</span> },\n  ...\n]\n</code></pre>\n<p>Using lazy loading will make the initial load of our applications faster and will make sure only code that is actually needed is loaded.</p>\n"
    },
    "AvD9O": {
      "id": "AvD9O",
      "slug": "template-whitespace",
      "title": "Remove Template Whitespace",
      "source": "https://github.com/mgechev/angular-performance-checklist",
      "author": {
        "name": "Minko Gechev",
        "url": "https://twitter.com/mgechev"
      },
      "content": "<h3>Remove Template Whitespace</h3>\n<p>Although we don’t see the whitespace character (a character matching the <code>\\s</code> regex) it is still represented by bytes which are transfered over the network. If we reduce the whitespace from our templates to minimum we will be respectively able to drop the bundle size of the AoT code even further.</p>\n<p>Thankfully, we don’t have to do this manually. The <code>ComponentMetadata</code> interface provides the property <code>preserveWhitespaces</code> which by default has value <code>true</code>, because removing the whitespace always may influence the DOM layout. In case we set the property to <code>false</code> Angular will trim the unnecessary whitespace which will lead to further reduction of the bundle size.</p>\n<ul>\n<li><a href=\"https://angular.io/api/core/Component#preserveWhitespaces\">preserveWhitespaces in the Angular docs</a></li>\n</ul>\n"
    },
    "PaBkH": {
      "id": "PaBkH",
      "slug": "404-route",
      "title": "404 route",
      "content": "<h3>Defining a 404 route</h3>\n<p>Every application should define a 404 route. This is a route to be shown whenever the user tries to go to an non existing route.</p>\n<pre class=\"hljs\"><code>[\n  ...,\n  { path: <span class=\"hljs-string\">'**'</span>, redirectTo: <span class=\"hljs-string\">'/not-found'</span>, component: <span class=\"hljs-string\">'NotFoundComponent'</span> },\n]\n</code></pre>\n<p>This route definition uses a wildcard as a path. Since the Angular router will render the first definitions that matches, be sure to always put this route definition last!</p>\n"
    },
    "5ScV4": {
      "id": "5ScV4",
      "slug": "default-route",
      "title": "Default route",
      "content": "<h3>Defining a default route</h3>\n<p>Every application should define a default route. This is the route that will be used whenever the user goes to ‘/’.</p>\n<pre class=\"hljs\"><code>[\n  { path: <span class=\"hljs-string\">''</span>, redirectTo: <span class=\"hljs-string\">'/heroes'</span>, pathMatch: <span class=\"hljs-string\">'full'</span> },\n  ...\n]\n</code></pre>\n<p>Note that <code>pathMatch: full</code> should be used to make sure that this route definitions is only triggered when the user is going to ‘/’.</p>\n"
    },
    "Z1WXxTy": {
      "id": "Z1WXxTy",
      "slug": "preloading",
      "title": "Preloading strategy",
      "content": "<h3>Define a preloading strategy</h3>\n<p>When using lazy loading, it is interesting to define a preloading strategy. This strategy will define when modules, that are not yet requested, should be loaded.</p>\n<p>Depending on the application you are building and with what type of internet connection it will be used, a different strategy should be used.\nWhen working on an application that will be used only on a steady wifi connection, it makes sense to preload all of the modules. When your application will be used mainly on slow 3G connections, you should only load the most likely to be used modules.</p>\n<h6>Defining a custom preload strategy</h6>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppPreloadingStrategy <span class=\"hljs-keyword\">implements</span> PreloadingStrategy {\n    preload(route: Route, load: <span class=\"hljs-built_in\">Function</span>): Observable&lt;<span class=\"hljs-built_in\">any</span>&gt; {\n       <span class=\"hljs-comment\">// implement your strategy here</span>\n    } \n}\n</code></pre>\n<h6>Define the strategy to be used</h6>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// Existing </span>\nRouterModule.forRoot(routes, { preloadingStrategy: PreloadAllModules })\n<span class=\"hljs-comment\">// Custom</span>\nRouterModule.forRoot(routes, { preloadingStrategy: AppPreloadingStrategy })\n</code></pre>\n"
    },
    "bkHEY": {
      "id": "bkHEY",
      "slug": "caching",
      "title": "Caching",
      "content": "<h3>Caching</h3>\n"
    },
    "ZzpwmT": {
      "id": "ZzpwmT",
      "slug": "pipeable-operators",
      "title": "Pipeable Operators",
      "content": "<h5>Pipeable Operators</h5>\n"
    },
    "ZHuJoA": {
      "id": "ZHuJoA",
      "slug": "subjects",
      "title": "Subjects",
      "content": "<h5>Subjects</h5>\n"
    },
    "ZBbo7y": {
      "id": "ZBbo7y",
      "slug": "subscriptions",
      "title": "Subscriptions",
      "content": "<h5>Subscriptions</h5>\n"
    }
  }
}