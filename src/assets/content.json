{
  "categories": {
    "architecture": {
      "title": "Architecture",
      "summary": "This category summarizes best practices regarding architecture.",
      "slug": "architecture",
      "enabled": true,
      "items": [
        "Z1uCcrx",
        "l2hnF",
        "Z2n0Qqm",
        "opRwV",
        "Z24l73x"
      ]
    },
    "components": {
      "title": "Components",
      "summary": "This category summarizes best practices regarding Components.",
      "slug": "components",
      "enabled": true,
      "items": [
        "2eREkv",
        "2rF4Hq",
        "590AM",
        "ZXTLWo"
      ]
    },
    "ngrx": {
      "title": "NgRx",
      "summary": "This category summarizes best practices regarding NgRx.",
      "slug": "ngrx",
      "enabled": true,
      "items": [
        "Z2exNXo",
        "iglD3",
        "4gz6q",
        "Z1vJTA4",
        "2sJuJG",
        "ZlteSK",
        "Myhw4"
      ]
    },
    "performance": {
      "title": "Performance",
      "summary": "This category contains a list of practices which will help us boost the performance of our Angular applications. It covers different topics - from server-side pre-rendering and bundling of our applications, to runtime performance and optimization of the change detection performed by the framework.",
      "slug": "performance",
      "enabled": true,
      "items": [
        "2g7vDW",
        "Z13mvQ4",
        "ZfxFUd"
      ]
    },
    "router": {
      "title": "Router",
      "summary": "This category summarizes best practices regarding routing.",
      "slug": "router",
      "enabled": true,
      "items": [
        "PaBkH",
        "5ScV4",
        "iOnTI",
        "Z1WXxTy",
        "wpc6W"
      ]
    },
    "rxjs": {
      "title": "RxJS",
      "summary": "This category summarizes best practices regarding RxJS.",
      "slug": "rxjs",
      "enabled": true,
      "items": [
        "Z1PcMvX",
        "Or6Kp",
        "ZzpwmT",
        "Iqkhs"
      ]
    },
    "tooling": {
      "title": "Tooling",
      "summary": "This category summarizes best practices regarding tooling.",
      "slug": "tooling",
      "enabled": true,
      "items": [
        "Z1yDHe5",
        "Z1uf1Rj",
        "V15M7"
      ]
    },
    "typescript": {
      "title": "Typescript",
      "summary": "This category summarizes best practices regarding Typescript.",
      "slug": "typescript",
      "enabled": true,
      "items": [
        "Z2hzSxp",
        "23KPo0",
        "12Aq23",
        "ZRBVWY",
        "ZEhkug"
      ]
    }
  },
  "items": {
    "Z1uCcrx": {
      "id": "Z1uCcrx",
      "slug": "business-logic-in-services",
      "title": "Business Logic in Services",
      "content": "<h3>Problem</h3>\n<p>With Angular we are creating applications using a layered architecture. Every layer in our architecture should have it’s own responsability. This means we have decoupled layers and separation of concerns.\nBusiness logic in our applications does not belong in the component layer. The component layer is purely meant to be used for visualisation and handling user input. Business logic should be moved to the service layer.</p>\n<h3>Solution</h3>\n<p>In the following example, we are using the <code>HttpClient</code> to fetch data from the backend. This should not be done inside of the component layer but moved to a service.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit, OnDestroy {\n  data$;\n  \n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> http: HttpClient</span>) {\n  }\n  \n  ngOnInit() {\n    <span class=\"hljs-keyword\">this</span>.data$ = <span class=\"hljs-keyword\">this</span>.http.get(<span class=\"hljs-string\">'http://some-api.com/'</span>);\n  }\n}\n</code></pre>\n<p>We move this into a <code>PeopleService</code>.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit, OnDestroy {\n  data$;\n  \n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> peopleService: PeopleService</span>) {\n  }\n  \n  ngOnInit() {\n    <span class=\"hljs-keyword\">this</span>.data$ = <span class=\"hljs-keyword\">this</span>.peopleService.getPeople();\n  }\n}\n</code></pre>\n"
    },
    "l2hnF": {
      "id": "l2hnF",
      "slug": "file-naming",
      "title": "Use descriptive file names",
      "content": "<h3>Problem</h3>\n<p>When applications grow over time, it can be quite hard to identify and find certain parts in our application. When we don’t give a descriptive name to our files, this makes it even more difficult to do so.</p>\n<h3>Solution</h3>\n<h4>Separate file names with dots and dashes</h4>\n<p>It is recommended to separate words with dashes and dots to separate the descriptive name from the type. The descriptive name of a file should describe the component’s feature.</p>\n<p>Also, try to use conventional suffix that describe the type of the file, e.g. <code>.component.ts</code>, <code>.directive.ts</code>, <code>.service.ts</code>, <code>.module.ts</code>, <code>.pipe.ts</code>.</p>\n<p>Here are a few examples:</p>\n<ul>\n<li><code>app.component.ts</code></li>\n<li><code>contacts.service.ts</code></li>\n<li><code>product-list.component.ts</code></li>\n</ul>\n<p>Using such naming convention helps to provide a consistent way to find content very quickly and easily. Consistency will save you time and make you and your team more efficient.</p>\n<h4>Use the name and type of the file for your class names</h4>\n<p>If the file you are working on is <code>app.component.ts</code> it is obvious that this must be a component. It also tells us the name of this component, which is <code>app</code>. This means we’d call our class <code>AppComponent</code>:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({ ... })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppComponent { }\n</code></pre>\n<p>Here’s another example of a class defined in <code>product-list.component.ts</code>:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({ ... })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> ProductListComponent { }\n</code></pre>\n"
    },
    "Z2n0Qqm": {
      "id": "Z2n0Qqm",
      "slug": "immutability",
      "title": "never mutate objects, work immutable",
      "content": "<h3>Problem</h3>\n<p>Performing a deep comparison of objects in javascript is a quite costly operation. Reference checks however, are extremely fast and easy. For that reason, Angular and lots of other libraries depend on reference check comparisons instead of doing a deep comparison. If you mutate objects, you are bound to see some weird and unexpected behavior.</p>\n<p>Some examples of things that don’t work properly when mutating objects are:</p>\n<ul>\n<li>onPush strategy in Angular</li>\n<li>NgRx selectors</li>\n<li>RxJS operators such as <code>distinct</code>, <code>distinctUntilChanged</code>, <code>tap</code>, …</li>\n</ul>\n<h3>Solution</h3>\n<p>Instead of mutating objects, we need to work immutable. Immutability means that we will never mutate objects. Instead, when we want to change something, we can a copy of the objects with our changes.</p>\n<p>Next, we have an example using the object spread operator:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> state = {\n  users: [\n    {id: <span class=\"hljs-number\">1</span>, name: <span class=\"hljs-string\">\"Dominic Elm\"</span>},\n    {id: <span class=\"hljs-number\">2</span>, name: <span class=\"hljs-string\">\"Kwinten Pisman\"</span>},\n  ],\n  selectedUserId = <span class=\"hljs-number\">1</span>;\n}  \n\n<span class=\"hljs-keyword\">const</span> newState = {...state, selectedUserId: <span class=\"hljs-number\">2</span>};\n</code></pre>\n<p>We have a state object with some data. We want to update the <code>selectedUserId</code> property, without mutating the original object. Using the object spread operator, we create a new object, keeping the same reference to the <code>users</code> array, but changing the <code>selectedUserId</code> to 2.</p>\n<p><strong>Note:</strong> This is just one of the ways we can work immutable. The spread operator is available in the latest versions of javascript. There are also libraries that can help us to work immutable that will be more performant for big collections. The point here however is to work immutable and never mutate any object. Regardless of how you accomplish this.</p>\n"
    },
    "opRwV": {
      "id": "opRwV",
      "slug": "modules-and-services",
      "title": "Provide shared services only at root module",
      "content": "<h3>Problem</h3>\n<p>Due to the way DI in Angular is implemented, with an injector tree, we can provide instances of our service at multiple levels, e.g. component, directive or module. While we can use this feature, it’s not always what we want.</p>\n<p>Working with a shared module is a common and recommended way of working. This module can be used to share services, components, directives, pipes, … between different feature modules. If we import our shared module in multiple modules, we will provide the service multiple times and multiple instances will be generated, and we would like to avoid that here.</p>\n<h3>Solution</h3>\n<p>When we are creating our <code>SharedModule</code>, we only want to use the components everywhere but only provide the services in our root module, e.g. <code>AppModule</code>. We can accomplish this by leveraging the <code>forRoot</code> convention. In that scenario, our <code>SharedModule</code> would look like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [...modules],\n  declarations: [...declarations],\n  exports: [...declarations]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SharedModule {\n  <span class=\"hljs-keyword\">static</span> forRoot(): ModuleWithProviders {\n    <span class=\"hljs-keyword\">return</span> {\n      ngModule: SharedModule,\n      providers: [...services]\n    };\n  }\n}\n</code></pre>\n<p>Note that the actual module definion <strong>does not</strong> contain any providers.</p>\n<p>In our <code>AppModule</code>, we could use this module as follows:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [\n    ...modules,\n    SharedModule.forRoot()\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppModule {}\n</code></pre>\n<p>By calling the static <code>forRoot</code> method on the <code>SharedModule</code> you will import the entire module <strong>including</strong> its providers.</p>\n<p>In a feature module you would simply import the <code>SharedModule</code> <strong>without</strong> calling <code>forRoot</code>:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [\n    ...modules,\n    SharedModule\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeFeature {}\n</code></pre>\n<p>The fact that each component has its own Injector that is inherited from its parent Injector, allows us to ask for services provided at a root level. Hence, we have access to all the components, pipes, etc. provided by the <code>SharedModule</code> without creating multiple instances of its services.</p>\n<h3>Additional Resources</h3>\n<ul>\n<li><a href=\"https://blog.thoughtram.io/angular/2015/05/18/dependency-injection-in-angular-2.html\">Dependency Injection in Angular</a> by Pascal Precht</li>\n<li><a href=\"https://blog.thoughtram.io/angular/2016/09/14/bypassing-providers-in-angular-2.html\">Bypassing Providers in Angular</a> by Pascal Precht</li>\n<li><a href=\"https://blog.angularindepth.com/avoiding-common-confusions-with-modules-in-angular-ada070e6891f\">Avoiding common confusions with modules in Angular</a> by Maxim Koretskyi</li>\n</ul>\n"
    },
    "Z24l73x": {
      "id": "Z24l73x",
      "slug": "smart-and-dumb-components",
      "title": "Use smart and dumb components",
      "content": "<h3>Problem</h3>\n<p>Every major frontend framework is moving towards a component based architecture. Components are a combination of a little bit of HTML, JavaScript and CSS. If we start injecting services in every component, tightly couple it by letting it fetch its own data, we are not leveraging the power of a component based architecture.</p>\n<h3>Solution</h3>\n<p>The most advocated way to arrang your is to use smart and dumb components (there is a variety of other names for this principle but the general principle is the same).</p>\n<h4>Component Types</h4>\n<h5>Dumb Components</h5>\n<ul>\n<li>Receives data through <code>@Input</code>s and communicates only with it’s direct parent through <code>@Output</code>s.</li>\n<li>Dumb components should not receive <code>Observables</code> as inputs</li>\n<li>It does not know about the rest of the application. It is dumb and does not know where it is being used.</li>\n<li>Can contain business logic, but only logic that belongs to the scope of this component. For example, a pagination component can contain logic to calculate the number of ‘boxes’ to show. It does not know what happens when a user clicks a page number. In that case, it throws a custom event to notify its parent the that something has happened. The parent component then decides what happens.</li>\n<li>It can use other dumb components as children.</li>\n<li>It can inject services that are related to the view layer of your application (think <code>TranslateService</code>, <code>Router</code>, …) but never services to fetch its own data.</li>\n</ul>\n<h4>Smart Component</h4>\n<ul>\n<li>Knows about the application and will fetch data.</li>\n<li>It passes data down to dumb components as much as possible and mostly only contains the business logic to fetch the data.</li>\n<li>It is build up out of several dumb components.</li>\n<li>It listen for events thrown by the dumb components and performs the required action for them.</li>\n</ul>\n<h4>Benefits</h4>\n<ul>\n<li>Dumb components are completely reusable since they have a defined API and are independet of any buiness logic.</li>\n<li>Dumb components are easy to test as they are completely isolated.</li>\n<li>The entire architecture of your components becomes easier to reason about. If there is a business logic or data fetching problem, you know that you need to start searching in your smart components since this is the responsability of that component.</li>\n</ul>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\">Presentational and container components</a> by Dan Abramov.</li>\n<li><a href=\"https://blog.angular-university.io/angular-2-smart-components-vs-presentation-components-whats-the-difference-when-to-use-each-and-why/\">Smart components vs Presentational components</a> by Angular University.</li>\n<li><a href=\"https://blog.strongbrew.io/the-smart-vs-dumb-components-quiz/\">The smart vs dumb component quiz</a> by Kwinten Pisman.</li>\n</ul>\n"
    },
    "2eREkv": {
      "id": "2eREkv",
      "slug": "clean-up-resource-in-ng-on-destroy",
      "title": "release resources in ngOnDestroy",
      "content": "<h4>Problem</h4>\n<p>When creating Angular components, we need to use resources to get user input, fetch data from the backend, create animations, … The way we can do this can vary. We could use Observables, browser APIs, event listeners and much more. When using resources, we also need to release those resources when they are no longer required.\nIf we do <strong>not</strong> do this, than we will introduce memory leaks which will make our application crash and introduce other unwanted behavior.</p>\n<h4>Solution</h4>\n<p>We can hook into the lifecyle of our component to known when to release the resources that we used. Whenever Angular is going to destroy our component, it will call the <code>onDestroy</code> lifecycle hook.</p>\n<p>In the following example, we set up a function to be executed every 5000ms using the <code>setTimeout</code> API. In the <code>ngOnDestroy</code> hook, we unregister the interval and release the resources.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit, OnDestroy {\n  timeoutId;\n  \n  ngOnInit() {\n    <span class=\"hljs-keyword\">this</span>.intervalId = setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {...}, <span class=\"hljs-number\">5000</span>); \n  }\n  \n  ngOnDestroy() {\n    clearInterval(<span class=\"hljs-keyword\">this</span>.intervalId);\n  }\n}\n</code></pre>\n"
    },
    "2rF4Hq": {
      "id": "2rF4Hq",
      "slug": "dont-use-property-bindings-to-pass-static-strings",
      "title": "don't use property bindings to pass static strings",
      "content": "<h3>Problem</h3>\n<p>Property bindings in Angular allows us to bind to properties. During change detection, when a component is checked, all the bindings for that component are being checked to see if they are updated. This means that the more bindings, the slower the CD cycle will be.\nIf we have static strings that we want to pass to a native HTML element or a component, it’s not necessary to use a property binding as the value will never change. But it will impact performance.</p>\n<h3>Solution</h3>\n<p>Only use a property binding for dynamic values. Use attributes to pass a static string value.</p>\n<p>In the following example, we pass a static string to the input. This doesn’t make sense as this string is passed statically and will never change.</p>\n<pre class=\"hljs\"><code>&lt;input [id]=<span class=\"hljs-string\">\"'exampleId'\"</span> /&gt;\n</code></pre>\n<p>In order to fix this, we can remove the property binding.</p>\n<pre class=\"hljs\"><code>&lt;input id=<span class=\"hljs-string\">\"exampleId\"</span> /&gt;\n</code></pre>\n"
    },
    "590AM": {
      "id": "590AM",
      "slug": "minimum-logic-in-templates",
      "title": "minimum logic in templates",
      "content": "<h3>Problem</h3>\n<p>When we put too much logic in our templates, we are making our applications more difficult to test. The fastest way to write and execute tests is by using simple unit tests. But, templates are not testable with plain unit tests.\nIt can also make our template less readable.</p>\n<h3>Solution</h3>\n<p>Avoid putting to much logic in your templates.</p>\n<p>For example here, we have have an <code>ngIf</code> that has too much logic.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  template: <span class=\"hljs-string\">`&lt;div *ngIf=\"users &amp;&amp; users.length &gt; 1 &amp;&amp; visible\"&gt;content to show&lt;/div&gt;`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent {\n  users: User[];\n  visible: <span class=\"hljs-built_in\">boolean</span>;\n}\n</code></pre>\n<p>We can refactor this by putting the logic inside our component’s class. This will make our template more readable and this logic easier to test.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  template: <span class=\"hljs-string\">`&lt;div *ngIf=\"usersExistsAndVisible()\"&gt;content to show&lt;/div&gt;`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent {\n  users: User[];\n  visible: <span class=\"hljs-built_in\">boolean</span>;\n  \n  usersExistsAndVisible() {\n    <span class=\"hljs-keyword\">return</span> users &amp;&amp; users.length &gt; <span class=\"hljs-number\">1</span> &amp;&amp; visible;\n  }\n}\n</code></pre>\n"
    },
    "ZXTLWo": {
      "id": "ZXTLWo",
      "slug": "ng-oninit-vs-constructor",
      "title": "put init logic in the ngOnInit lifecycle hook",
      "content": "<h3>Problem</h3>\n<p>The constructor is a function of a class that is being called during the construction of an instance of that component. Angular leverages the constructor to provide us with the dependencies we requested.\nIt doesn’t mean however, that Angular is fully finished with the creation of this component. The <code>@Input</code> bindings for exmaple will not be initialised yet. Angular will call the <code>ngOnInit</code> lifecycle hook when it is ready.</p>\n<p>If we put logic inside the  constructor, we are doing things before Angular has finished creating the component.\nIt also impacts the way we can test our code. In a unit test, we will probably instantiate an instance of a component in a <code>beforeEach</code> block. If this already initialises some logic, this will impact every separate test and makes it hard to test that logic.</p>\n<h3>Solution</h3>\n<p>To fix this, we need to move all initialisation logic that needs to be tested and that uses <code>@Input</code> bindings to the <code>ngOnInit</code> lifecycle hook.</p>\n<p>From:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  template: <span class=\"hljs-string\">`...`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent {\n  users$: Observable&lt;User&gt;;\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> usersService: UsersService</span>) {\n    <span class=\"hljs-keyword\">this</span>.users$ = <span class=\"hljs-keyword\">this</span>.usersService.getUsers();\n  }\n  \t\n  ngOnInit() {\n  }\n}\n\n</code></pre>\n<p>To:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  template: <span class=\"hljs-string\">`...`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent {\n  users$: Observable&lt;User&gt;;\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> usersService: UsersService</span>) {\n  }\n  \t\n  ngOnInit() {\n    <span class=\"hljs-keyword\">this</span>.users$ = <span class=\"hljs-keyword\">this</span>.usersService.getUsers();\n  }\n}\n\n</code></pre>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://blog.angularindepth.com/the-essential-difference-between-constructor-and-ngoninit-in-angular-c9930c209a42\">The essential difference between Constructor and ngOnInit in Angular</a> by Maxim Koretskyi.</li>\n</ul>\n"
    },
    "Z2exNXo": {
      "id": "Z2exNXo",
      "slug": "action-hygiene",
      "title": "capture events with actions, not commands",
      "content": "<h3>Problem</h3>\n<p>When using NgRx, we are constantly dispatching actions to the store. These can be dispatched from different places such as components and effects. It can get really hard to see where all these actions originated from, why they were send and how they are impacting the state.</p>\n<h3>Solution</h3>\n<p>By changing the way we name our actions, we can &amp;</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=JmnsEvoy-gY\">Good action hygiene</a></li>\n</ul>\n"
    },
    "iglD3": {
      "id": "iglD3",
      "slug": "actions-are-defined-as-classes",
      "title": "define actions as classes",
      "content": "<h3>Problem</h3>\n<p>When we send an action to the store, we need to send an object that has a type property and an optional payload property. We could recreate an object every time we want to send that but that would break the DRY principle.</p>\n<p>One of the promises in NgRx is that it provides extreme type safety. This is something that cannot be achieved with plain objects.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://blog.strongbrew.io/type-safe-actions-in-reducers/\">Type safe actions in reducers</a> by Kwinten Pisman.</li>\n</ul>\n"
    },
    "4gz6q": {
      "id": "4gz6q",
      "slug": "big-lists-are-normalised",
      "title": "use the entity pattern for big lists",
      "content": "<h3>Problem</h3>\n<p>In our applications we use a lot of arrays to store our data. When we fetch a list of users and we want to show them in the view, we can loop over them really easily using the <code>*ngFor</code> directive. We can put that data in our store so that we, for example, don’t have to fetch it again later.</p>\n<p>But arrays are not the most performant solution when we want to update, delete or get a single element out of the list. They all have a complexity of O(n). And this is not interesting for when we are taking data out of the store.</p>\n<h3>Solution</h3>\n<p>To make getting data out of the store, we can adopt the entity pattern. This means that we will no longer store the data as an array but transform it to an object where the key is the unique identifier of the element and the value is the actual element. It means that we will transform this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> contacts = [\n  { id: <span class=\"hljs-number\">1</span>, name: <span class=\"hljs-string\">'Dominic Elm'</span> },\n  { id: <span class=\"hljs-number\">2</span>, name: <span class=\"hljs-string\">'Kwinten Pisman'</span> }\n]\n</code></pre>\n<p>into this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> entities = {\n  <span class=\"hljs-number\">1</span>: { id: <span class=\"hljs-number\">1</span>, name: <span class=\"hljs-string\">'Dominic Elm'</span> },\n  <span class=\"hljs-number\">2</span>: { id: <span class=\"hljs-number\">2</span>, name: <span class=\"hljs-string\">'Kwinten Pisman'</span> },\n}\n</code></pre>\n<p>Now, finding an element, deleting and updating all have a complexity of O(1).</p>\n<p><strong>Note:</strong> As this is a common pattern in NgRx, there is a seperate package that will help us to implement the entity pattern called <code>@ngrx/entity</code>.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://github.com/ngrx/platform/tree/master/docs/entity\">@ngrx/entity</a></li>\n</ul>\n"
    },
    "Z1vJTA4": {
      "id": "Z1vJTA4",
      "slug": "dont-store-state-that-can-be-derviced",
      "title": "don't store state that can be derived",
      "content": "<h3>Problem</h3>\n<p>We can use <code>@ngrx/store</code> to store data. When we store duplicate data, we are making our reducer logic way more difficult. Take a look at the following type definiton for a potential state object:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> ApplicationState {\n  users: <span class=\"hljs-built_in\">Array</span>&lt;User&gt;;\n  selectedUserId: <span class=\"hljs-built_in\">number</span>;\n  selectedUser: User;\n}\n</code></pre>\n<p>In this scenario, we are both storing the id of the <code>selectedUser</code> and the object of the <code>selectedUser</code>. This poses a lot of problems. First of all, when we change the selected user, we need to remember to update both references. But even worse, what if we update the user that is currently selected. Then we need to update both the reference in the <code>users</code> array and the <code>selectedUser</code>. This will make it really easy to make mistakes.</p>\n<h3>Solution</h3>\n<p>To fix this, we <strong>shouldn’t store state that can be derived</strong>. If we store the <code>users</code> and the <code>selectedUserId</code>, we can easily derive which user is selected. This is logic that we can put in a selector. The state object’s type would look like this.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> ApplicationState {\n  users: <span class=\"hljs-built_in\">Array</span>&lt;User&gt;;\n  selectedUserId: <span class=\"hljs-built_in\">number</span>;\n}\n</code></pre>\n<p>In this scenario, when we update a user, we only need to update the reference in the <code>users</code> array.</p>\n"
    },
    "2sJuJG": {
      "id": "2sJuJG",
      "slug": "not-everything-in-the-store",
      "title": "Not everything is in the store",
      "content": "<h3>Problem</h3>\n<p>NgRx/Store (or Redux in general) provides us with a lot of great features and can be used in a lot of use cases. In some cases however, this pattern can be overkill. Implementing it means that we get the downsides without the benefits.</p>\n<h3>Solution</h3>\n<p>The NgRx team created a principle called ‘SHARI’ that can be used as a rule of thumb on what data needs to be added to the store.</p>\n<p>Shared - State that is shared between many components and services\nHydrated - State that is persisted and hydrated from\nAvailabe - State that needs to be available when re-entering routes\nRetrieved - State that needs to be retrieved with a side effect\nImpacted - State that is impacted by actions from other sources</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=t3jx0EC-Y3c\">Reducing the Boilerplate with NgRx</a> by Mike Ryan and Brandon Roberts</li>\n<li><a href=\"https://blog.strongbrew.io/do-we-really-need-redux/\">Do we really need @ngrx/store</a> by Brecht Billiet</li>\n</ul>\n"
    },
    "ZlteSK": {
      "id": "ZlteSK",
      "slug": "reducers-are-pure-functions",
      "title": "reducers are pure functions",
      "content": "<h3>Problem</h3>\n<p>Reducers are responsible for updating the state in our application based on actions. It is extremely important that these are deterministic so that every action will always have the same result. If they are no longer deterministic, we can no longer trust them to manage our state.</p>\n<h3>Solution</h3>\n<p>By writing our reducers as pure functions, we are 100% sure that the reducer is determinstic and can be used to manage our state. Properties of a pure function are:</p>\n<ul>\n<li>it does not depend on side effects</li>\n<li>it does not nutate any of its inputs</li>\n<li>if you call it over and over again, with the same arguments, you always get back the same results</li>\n</ul>\n<p>These properties are exactly what we need for our reducers to be deterministic and to comply with the key concepts of Redux.</p>\n"
    },
    "Myhw4": {
      "id": "Myhw4",
      "slug": "use-selectors",
      "title": "use selectors to select data from the store",
      "content": "<h3>Problem</h3>\n<p>When we want to fetch data from the store, we can use querries to get the data out. These querries are functions that take have the following signature <code>(state: T) =&gt; K</code>. While getting state from the store, we can execute some pretty complex and potentially ineffecient logic. Every time the state changes, this logic will be reexecuted.</p>\n<p>These querries we define can also not be reused to create new ones. This means that we have to define the same querries in multiple location violating the DRY principle.</p>\n<h3>Solution</h3>\n<p><code>@ngrx/store</code> provides us with the concept of selectors. A selector helps us to build up querries that have a type signature of <code>(state: T): K</code>. The great benefit of these selectors is that they are composable. <code>@ngrx</code> exposes a <code>createSelector</code> function that accepts other selectors to create new ones based on these. This means that we only have to define every selector just once and reuse them in multiple places.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> selectFeature = <span class=\"hljs-function\">(<span class=\"hljs-params\">state: AppState</span>) =&gt;</span> state.feature;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> selectFeatureCount = createSelector(\n  selectFeature,\n  <span class=\"hljs-function\">(<span class=\"hljs-params\">state: FeatureState</span>) =&gt;</span> state.counter\n);\n</code></pre>\n<p>Another benefit of these selectors is that they use memoization. This means that the selector logic will <strong>not</strong> be reexecuted if the source selectors did not update. This means that the complex logic we might execute to get data from the store is only executed when it is actually needed.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://github.com/ngrx/platform/blob/master/docs/store/selectors.md\">Selectors in Ngrx</a></li>\n</ul>\n"
    },
    "2g7vDW": {
      "id": "2g7vDW",
      "slug": "aot-compilation",
      "title": "use AOT compilation for prod builds",
      "source": "https://github.com/mgechev/angular-performance-checklist",
      "author": {
        "name": "Minko Gechev",
        "url": "https://twitter.com/mgechev"
      },
      "content": "<h3>Problem</h3>\n<p>The biggest part of the code that we ship to the browser when we use Angular is the compiler. The compiler is needed to transform our HTML-like templates to Javascript. This is doesn’t only has a negative impact on the bundle size but also on the performance as this process is computationally expensive.</p>\n<h3>Solution</h3>\n<p>We can avoid shipping the compiler by peforming the compile step as part fo the build step. We can achieve this by using AOT.</p>\n<p>AoT can be helpful not only for achieving more efficient bundling by performing tree-shaking, but also for improving the runtime performance of our applications. The alternative of AoT is Just-in-Time compilation (JiT) which is performed runtime, therefore we can reduce the amount of computations required for rendering of our application by performing the compilation as part of our build process.</p>\n<h3>Tooling</h3>\n<ul>\n<li><a href=\"https://github.com/angular/angular/tree/master/packages/compiler-cli\">@angular/compiler-cli</a> - a drop-in replacement for <a href=\"https://www.npmjs.com/package/typescript\">tsc</a> which statically analyzes our application and emits TypeScript/JavaScript for the component’s templates.</li>\n<li><a href=\"https://github.com/mgechev/angular-seed\">angular2-seed</a> - a starter project which includes support for AoT compilation.</li>\n<li><a href=\"https://cli.angular.io/\">Angular CLI</a> Using the ng serve --prod</li>\n</ul>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"http://blog.mgechev.com/2016/08/14/ahead-of-time-compilation-angular-offline-precompilation/\">Ahead-of-Time Compilation in Angular</a> by Minko Gechev</li>\n</ul>\n"
    },
    "Z13mvQ4": {
      "id": "Z13mvQ4",
      "slug": "change-detection-optimization",
      "title": "use onPush CD strategy on dumb components",
      "content": "<h3>Problem</h3>\n<p>Change detection (CD) in Angular is performed from top to bottom. This means that everything is only checked once. This is a huge difference compared to angular.js where change detection was performend in cycles till everything was considered stable.</p>\n<p>But, it still means that everything is checked everytime CD is triggered, even things that we know for sure have not changed.</p>\n<h3>Solution</h3>\n<p>Angular components can use different strategies for change detection. They can either use ‘default’ or ‘onPush’.</p>\n<p>The default strategy means that the component will be checked during every CD cycle.</p>\n<p>With the ‘onPush’ strategy, the component (and all of its children!) will only be checked if the <code>@Input</code>s of that component have changed reference. This means that we can easily tell Angular to not run CD for huge parts of our component tree, speeding up CD a lot!</p>\n<p>We can enable the ‘onPush’ strategy like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  ...\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\n</code></pre>\n<p><strong>Note:</strong> This also implies that we should always try to work immutable. Let’s say that we add an element to an array by mutating the array and we pass the array to a component to visualise it. If we apply the ‘onPush’ strategy for this component, we wouldn’t see the changes. Angular will not check if the array’s content has changed. It will only check the reference. As the reference has not changed, it means that CD will not run for that component and the view will not be updated!</p>\n<p><strong>Note2:</strong> This also means that, every component we apply this strategy to, has to be dumb. If the component fetches its own data, we cannot have the ‘onPush’ strategy. Because in that case, the <code>@Input</code>s changing wouldn’t be the only reason to run CD, but also data being fetched.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html\">Angular change detection explained</a> by Pascal Precht</li>\n</ul>\n"
    },
    "ZfxFUd": {
      "id": "ZfxFUd",
      "slug": "track-by-option-on-ng-for",
      "title": "use trackBy option on *ngFor",
      "source": "https://github.com/mgechev/angular-performance-checklist#use-trackby-option-for-ngfor-directive",
      "author": {
        "name": "Minko Gechev",
        "url": "https://twitter.com/mgechev"
      },
      "content": "<h3>Problem</h3>\n<p>The <code>*ngFor</code> directive is used for rendering a collection. By default <code>*ngFor</code> identifies object uniqueness by reference.</p>\n<p>Which means when developer breaks reference to object during updating item’s content Angular treats it as removal of the old object and addition of the new object. This effects in destroying old DOM node in the list and adding new DOM node on its place.</p>\n<h3>Solution</h3>\n<p>We can provide a hint for angular how to identify object uniqueness: custom tracking function as the <code>trackBy</code> option for the <code>*ngFor</code> directive. Tracking function takes two arguments: index and item. Angular uses the value returned from tracking function to track items identity. It is very common to use ID of the particular record as the unique key.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  selector: <span class=\"hljs-string\">'yt-feed'</span>,\n  template: <span class=\"hljs-string\">`\n    &lt;h1&gt;Your video feed&lt;/h1&gt;\n    &lt;yt-player *ngFor=\"let video of feed; trackBy: trackById\" [video]=\"video\"&gt;&lt;/yt-player&gt;\n  `</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> YtFeedComponent {\n  feed = [\n    {\n      id: <span class=\"hljs-number\">3849</span>, <span class=\"hljs-comment\">// note \"id\" field, we refer to it in \"trackById\" function</span>\n      title: <span class=\"hljs-string\">\"Angular in 60 minutes\"</span>,\n      url: <span class=\"hljs-string\">\"http://youtube.com/ng2-in-60-min\"</span>,\n      likes: <span class=\"hljs-string\">\"29345\"</span>\n    },\n    <span class=\"hljs-comment\">// ...</span>\n  ];\n\n  trackById(index, item) {\n    <span class=\"hljs-keyword\">return</span> item.id;\n  }\n}\n</code></pre>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://angular.io/docs/ts/latest/api/common/index/NgFor-directive.html\">“NgFor directive”</a> - official documentation for <code>*ngFor</code></li>\n<li><a href=\"https://netbasal.com/angular-2-improve-performance-with-trackby-cc147b5104e5\">“Angular — Improve performance with trackBy”</a> - shows gif demonstration of the approach</li>\n</ul>\n"
    },
    "PaBkH": {
      "id": "PaBkH",
      "slug": "404-route",
      "title": "404 Route",
      "content": "<h3>Problem</h3>\n<p>There are multiple reasons why we need to make sure that we have a fallback for when a page is not found.</p>\n<ul>\n<li>Our users are humans. Humans are quite error-prone. This means that they are likely to mistype a url at some point.</li>\n<li>over time, our applications will change. Users might bookmark urls for pages which are not supported anymore.</li>\n</ul>\n<h3>Solution</h3>\n<p>Every application should define a 404 route. This is a route to be shown whenever the user tries to go to an non existing route.</p>\n<pre class=\"hljs\"><code>[\n  ...,\n  { path: <span class=\"hljs-string\">'**'</span>, redirectTo: <span class=\"hljs-string\">'/not-found'</span>, component: <span class=\"hljs-string\">'NotFoundComponent'</span> },\n]\n</code></pre>\n<p>This route definition uses a wildcard as a path. Since the Angular router will render the first definitions that matches, be sure to always put this route definition last!</p>\n"
    },
    "5ScV4": {
      "id": "5ScV4",
      "slug": "default-route",
      "title": "default route is defined",
      "content": "<h3>Problem</h3>\n<p>When users type in the url for your application, they do not know all the routes in our application. We need to make sure that we have a landing page or a redirect setup.</p>\n<h3>Solution</h3>\n<p>Every application should define a default route. This is the route that will be used whenever the user goes to <code>/</code>.</p>\n<pre class=\"hljs\"><code>[\n  { path: <span class=\"hljs-string\">''</span>, redirectTo: <span class=\"hljs-string\">'/heroes'</span>, pathMatch: <span class=\"hljs-string\">'full'</span> },\n  ...\n]\n</code></pre>\n<p>Note that <code>pathMatch: full</code> should be used to make sure that this route definitions is only triggered when the user is going to <code>/</code>.</p>\n"
    },
    "iOnTI": {
      "id": "iOnTI",
      "slug": "lazy-loading",
      "title": "feature modules are lazy loaded",
      "content": "<h3>Problem</h3>\n<p>When working with SPAs, we need to ship an entire applicaton to the client. The more bytes we need to ship, the slower it will be to load but also to parse. This will greatly influence the TTI (Time to interactive) of our application.</p>\n<p>We are shipping way too much javascript to the client.</p>\n<h3>Solution</h3>\n<p>Angular provides us with a module system. When we break up our application in feature modules, we can leverage this to only load the modules that are needed for the first page render. The other modules can be loaded only when they are needed. We can do this, when the user requests them or via a more sophisticated preloading strategy.</p>\n<p>The following module is <strong>not</strong> using lazy loading to load the <code>UsersModule</code>.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// app.routing.ts</span>\n<span class=\"hljs-keyword\">const</span> routes: Routes = [\n  ...\n  {path: <span class=\"hljs-string\">'users'</span>, component: UsersComponent}\n  ...\n];\n\n<span class=\"hljs-comment\">// app.module.ts</span>\n<span class=\"hljs-meta\">@NgModule</span>({\n  declarations: [AppComponent],\n  imports: [\n    ...\n    UsersModule, \n    RouterModule.forRoot(routes),\n  ],\n  bootstrap: [AppComponent]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppModule {}\n</code></pre>\n<p>This means that the <code>UsersModule</code> will be bundled in the main bundle. The main bundle contains all the code that is needed for the first page load. As the <code>UsersModule</code> is only needed when the users specifically goes to the <code>/users</code> page, it doesn’t make sense to load it at the first page load. We can leverage lazy loading to fix this.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// app.routing.ts</span>\n<span class=\"hljs-keyword\">const</span> routes: Routes = [\n  ...\n  {path: <span class=\"hljs-string\">'users'</span>, loadChildren: <span class=\"hljs-string\">'../users/usersModule#UserModule'</span>}\n  ...\n];\n\n<span class=\"hljs-comment\">// app.module.ts</span>\n<span class=\"hljs-meta\">@NgModule</span>({\n  declarations: [AppComponent],\n  imports: [\n    ...\n    UsersModule, \n    RouterModule.forRoot(routes),\n  ],\n  bootstrap: [AppComponent]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppModule {}\n</code></pre>\n<p>We updated the <code>/users</code> route to leverage the <code>loadChildren</code> property. This points to the module file of the <code>UsersModule</code> and always has a fixed format: <code>${pathToModule}${nameOfTheModule}</code>.</p>\n<p>By changing this, the <code>UsersModule</code> will be packaged in its own bundle and will only be loaded when the users navigates to the <code>/users</code> endpoint.</p>\n<h3>Resources</h3>\n<p><a href=\"https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4\">The cost of javascript</a> by Addy Osmani.</p>\n"
    },
    "Z1WXxTy": {
      "id": "Z1WXxTy",
      "slug": "preloading",
      "title": "Preloading Strategy",
      "content": "<h3>Problem</h3>\n<p>When we leverage lazy loading, we are only loading the code that is needed for the first page render. Modules that are not yet needed are not loaded.</p>\n<p>By default, the next modules will be loaded whenever the user requests them. This is not ideal in every scenario as it means that whenever the user requests a url, he has to start a new waiting period for the module to be loaded and parsed.</p>\n<h3>Solution</h3>\n<p>Depending on the application you are building and whether you have to deal with low bandwidth, it might be better to use a different strategy than only loading when the user requests it.</p>\n<p>When working on an application that will be used only on a steady WiFi connection, it makes sense to preload all of the modules. When your application will be used mainly on slow 3G connections, you should only load the modules that are most likely used.</p>\n<h4>Load all modules after first page render</h4>\n<p>One strategy provided by the Angular team is to preload all the modules. This means that, after the first page render, the modules will all be loaded in the background.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [\n    ...modules,\n    <span class=\"hljs-comment\">// Existing Preloading Strategy</span>\n    RouterModule.forRoot(routes, { preloadingStrategy: PreloadAllModules })\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppModule {}\n</code></pre>\n<h4>Defining a custom preloading strategy</h4>\n<p>If our users can both be on mobile and on wifi, it might make sense to only preload the modules if they are on wifi. To do this, we can implement a custom preloading strategy and use it.</p>\n<p>To do this, we need to implement the <code>PreloadingStrategy</code> interface.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// custom.preloading-strategy.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> MyCustomPreloadingStrategy <span class=\"hljs-keyword\">implements</span> PreloadingStrategy {\n  preload(route: Route, load: <span class=\"hljs-built_in\">Function</span>): Observable&lt;<span class=\"hljs-built_in\">any</span>&gt; {\n    <span class=\"hljs-comment\">// Implement your strategy here</span>\n  }\n}\n\n<span class=\"hljs-comment\">// app.module.ts</span>\n<span class=\"hljs-meta\">@NgModule</span>({\n  imports: [\n    ...modules,\n    <span class=\"hljs-comment\">// Custom Preloading Strategy</span>\n    RouterModule.forRoot(routes, { preloadingStrategy: MyCustomPreloadingStrategy });\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppModule {}\n</code></pre>\n"
    },
    "wpc6W": {
      "id": "wpc6W",
      "slug": "use-guards",
      "title": "restricted parts are protected by guards",
      "content": "<h3>Problem</h3>\n<p>Users should not be able to access pages that they don’t have access to. We could hide the menu item so they could not navigate to it by clicking on it but this means they can still manually type in the url to go to that page. We need some way to protect certain routes.</p>\n<h3>Solution</h3>\n<p>We can use guards to allow or disallow route changes. Every part of your application that should be limited to users with certain roles should be protected with guards.</p>\n<p>We can create a guard by creating a service that implements the <code>canActivate</code> interface to avoid users going to a certain component or a <code>canLoad</code> interface to avoid entire modules to be loaded.</p>\n<p>In the next example, we use a <code>canActivate</code> guard.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Injectable</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> UserHasRoleGuard <span class=\"hljs-keyword\">implements</span> CanActivate {\n\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> activatedRoute</span>) {}\n\n  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {\n    <span class=\"hljs-comment\">// return an Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean;</span>\n  }\n}\n\n</code></pre>\n<p>We can use it in our route definitions like this:</p>\n<pre class=\"hljs\"><code>[\n  ...,\n  { path: <span class=\"hljs-string\">'users'</span>, component: <span class=\"hljs-string\">'NotFoundComponent'</span>, canActivate: [UserHasRoleGuard] },\n]\n</code></pre>\n<p>You can see that the <code>canActivate</code> property takes an array. This means we can add multiple guards which will be called one after the other.</p>\n"
    },
    "Z1PcMvX": {
      "id": "Z1PcMvX",
      "slug": "async-pipe",
      "title": "Async pipe",
      "content": "<h3>Problem</h3>\n<p>In Angular, everything async is handled by Observables. An Observable can be triggered by subscribing. Whenever we do so, it is very important to also unsubscribe. Unsubscribing will clean up the resources being used by this stream. Otherwise, this might introduce memory leaks.</p>\n<p>If we manually subscribe, it also means that we manually have to unsubscribe. This is something that is easily forgotten.</p>\n<h3>Solution</h3>\n<p>Instead of manually subscribing, we can use the async pipe provided by Angular.</p>\n<p>The async pipe will:</p>\n<ul>\n<li>subscribe to an Observable</li>\n<li>unsubscribe from the Observable when it is destroyed</li>\n<li>mark this component for the next change detection cycle</li>\n</ul>\n<p>Using the async pipe as much as possible will make sure all the resources are cleaned up.</p>\n<p>For example:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  template: <span class=\"hljs-string\">`{{data$ | async}}`</span>,\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent {\n  data$ = interval(<span class=\"hljs-number\">1000</span>);\n}\n</code></pre>\n<h3>Resources</h3>\n<p><a href=\"https://blog.thoughtram.io/angular/2017/02/27/three-things-you-didnt-know-about-the-async-pipe.html\">Three things you didn’t know about the async pipe</a> by Christoph Burgdorf</p>\n"
    },
    "Or6Kp": {
      "id": "Or6Kp",
      "slug": "ngif-as-syntax",
      "title": "avoid x subscriptions to trigger x backend calls",
      "content": "<h3>Problem</h3>\n<p>An Observable is lazy by default but also unicast. This means that for every subscription, the Observable is executed. If the Observable is triggering a backend call when subscribed to, the following code will trigger two backend calls.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  &lt;some-component data=<span class=\"hljs-string\">\"data$ | async\"</span>&gt;&lt;<span class=\"hljs-regexp\">/some-component&gt;\n  &lt;some-other-component data=\"data$ | async\"&gt;&lt;/</span>some-component&gt;\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit, OnDestroy {\n  data$;\n  ...\n}\n</code></pre>\n<p>This is not the intended behavior. We want to fetch the data only once.</p>\n<h3>Solution</h3>\n<p>We can fix this problem in multiple ways, either with the ‘*ngIf as’ syntax, or by making our Observable hot.</p>\n<h4>*ngIf as syntax</h4>\n<p>We can use an <code>*ngIf</code> to hide an element. We can also leverage it to ‘unpack’ an obsevable and bind the value to a variable. We can then use that variable inside of the template.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  &lt;div *ngIf=<span class=\"hljs-string\">\"data$ | async as data\"</span>&gt;\n    &lt;some-component data=<span class=\"hljs-string\">\"data\"</span>&gt;&lt;<span class=\"hljs-regexp\">/some-component&gt;\n    &lt;some-other-component data=\"data\"&gt;&lt;/</span>some-component&gt;\n  &lt;<span class=\"hljs-regexp\">/div&gt;\n})\nexport class SomeComponent implements OnInit, OnDestroy {\n  data$;\n  ...\n}\n</span></code></pre>\n<p>By wrapping the components with a div that hides the element if no data is present, we were able to reduce the number of subscriptions from 2 to 1. This means that we only have a single subscription anymore. Using the ‘as …’ syntax, we can also ‘catch’ the event from that observable and bind it to a variable and use that variable to pass it to our components.</p>\n<h4>Make the Observable hot</h4>\n<p>We can transform our component so that the Observable will no longer trigger a backend call at every subscription. This fixes our problem as this means it doesn’t matter anymore if we have multiple subscriptions.</p>\n<p>To do this, we can use for example the <code>shareReplay</code> operator.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  &lt;some-component data=<span class=\"hljs-string\">\"sharedData$ | async\"</span>&gt;&lt;<span class=\"hljs-regexp\">/some-component&gt;\n  &lt;some-other-component data=\"sharedData$ | async\"&gt;&lt;/</span>some-component&gt;\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit, OnDestroy {\n  sharedData$ = data$.pipe(\n    shareReplay(<span class=\"hljs-number\">1</span>)\n  );\n  ...\n}\n</code></pre>\n"
    },
    "ZzpwmT": {
      "id": "ZzpwmT",
      "slug": "pipeable-operators",
      "title": "use pipeable operators",
      "content": "<h3>Problem</h3>\n<p>Since the release of RxJS 6, patch operators have been removed. This means that we can no longer use them.</p>\n<p>This means the following is no longer possible.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'rxjs/add/observable/interval'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'rxjs/add/operator/map'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'rxjs/add/operator/filter'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'rxjs/add/operator/switchMap'</span>;\n\nObservable.interval(<span class=\"hljs-number\">1000</span>)\n  .filter(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>)\n  .map(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x*<span class=\"hljs-number\">2</span>)\n  .switchMap(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> mapToObservable(x))\n</code></pre>\n<h3>Solution</h3>\n<p>Instead, we should be using pipeable operators.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { interval } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n<span class=\"hljs-keyword\">import</span> { filter, map, switchMap } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs/operators'</span>;\n\nObservable.interval(<span class=\"hljs-number\">1000</span>)\n  .pipe(\n    filter(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>),\n    map(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x*<span class=\"hljs-number\">2</span>),\n    switchMap(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> mapToObservable(x)),\n  );\n</code></pre>\n<p>Even if you are using the older versions of RxJS, all new code should be written using pipeable operators.</p>\n<h4>Upgrading</h4>\n<p>If you have a lot of code written using patch operators, you can use a script released written by Google engineers to do this upgrade automatically for you. You can find the script and how to use it in the ‘<a href=\"https://github.com/ReactiveX/rxjs-tslint#migration-to-rxjs-6\">rxjs-tslint</a>’ package.</p>\n"
    },
    "Iqkhs": {
      "id": "Iqkhs",
      "slug": "takeuntil-operator",
      "title": "don't manage subscriptions imperatively",
      "content": "<h3>Problem</h3>\n<p>When we subscribe to an Observable, we also need to unsubscribe to clean op it’s resources. Unsubscribing can be done like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// hold a reference to the subscription object</span>\n<span class=\"hljs-keyword\">const</span> subscription = interval(<span class=\"hljs-number\">1000</span>).subscribe(<span class=\"hljs-built_in\">console</span>.log);\n\n<span class=\"hljs-comment\">// use this subscription object to kill the subscription</span>\nsubscription.unsubscribe();\n</code></pre>\n<p>But if we have multiple subscriptions, we need to manage all of them. We could do this in an array but this is getting extremely verbose. We want to avoid having to do this.</p>\n<h3>Solution</h3>\n<p>RxJS provides us with the <code>takeUntil</code> operator. This operator will mirror the source observable ‘till a certain event happens’. In most cases, we want to stop listening to Observables when the component gets destroyed. This allows us to write something like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({...})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit, OnDestroy {\n  <span class=\"hljs-keyword\">private</span> stop$ = <span class=\"hljs-keyword\">new</span> Subject();\n  users;\n  \n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> usersService: UsersService</span>) {\n  }\n\t\n  ngOnInit() {\n    <span class=\"hljs-keyword\">this</span>.usersService.getUsers()\n     .pipe(\n       takeUntil(<span class=\"hljs-keyword\">this</span>.stop$)\n     )\n     .subscribe(\n       <span class=\"hljs-function\"><span class=\"hljs-params\">users</span> =&gt;</span> <span class=\"hljs-keyword\">this</span>.users = users;\n     );\n   }\n   \n   ngOnDestroy() {\n     <span class=\"hljs-keyword\">this</span>.stop$.next();\n   }   \n}\n</code></pre>\n<p>We create a Subject called <code>stop$</code> and when the <code>ngOnDestroy</code> hook is called, we <code>next</code> a value onto the Subject.</p>\n<p>The manual subscribe we defined in the <code>ngOnInit</code> hook uses the <code>takeUntil</code> operator in combination with the <code>this.stop$</code>. This means that the subscription will remain active <strong>until</strong> the <code>stop$</code> gets a value. After that, it will unsubscribe the source stream and complete it.</p>\n<p>This is way better than imperatively handling the subscriptions.</p>\n<p><strong>Note:</strong> Using the async pipe is even better as we don’t have to think about this at all. It will hook into the destroy lifecycle hook and unsubscribe for us.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://medium.com/@benlesh/rxjs-dont-unsubscribe-6753ed4fda87\">RxJS: don’t unsubscribe</a> by Ben Lesh</li>\n<li><a href=\"https://blog.angularindepth.com/rxjs-avoiding-takeuntil-leaks-fb5182d047ef\">RxJS: Avoiding takeUntil leaks</a> by Nicholas Jamieson</li>\n</ul>\n"
    },
    "Z1yDHe5": {
      "id": "Z1yDHe5",
      "slug": "angular-cli",
      "title": "Use the @angular/cli",
      "optional": true,
      "content": "<h3>Problem</h3>\n<p>When we ship our code to the browsers, it first needs to be bundled, it needs to be minified, it needs to be uglified, … This is a hard and cumbersome task to do and especially maintain.</p>\n<h3>Solution</h3>\n<p>Using the <code>@angular/cli</code> to take over the build process simplifies the development of your angular applications drastically. Aside from the build process, the CLI also provides you with code scaffolding which you can use to easily generate entire projects, components and much more.</p>\n<p>The CLI abstracts everything for us. This also means that when there are better solutions avaiable to perform for example the build process, if they integrate this, we get this update for free. Since version 6, it also possible to hook into the entire build process.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://cli.angular.io/\">Angular CLI</a> by the Angular team</li>\n<li><a href=\"https://medium.com/dailyjs/angular-cli-6-under-the-hood-builders-demystified-f0690ebcf01\">Angular CLI under the hood - builders demistified</a> by Evgeny Barabanov</li>\n</ul>\n"
    },
    "Z1uf1Rj": {
      "id": "Z1uf1Rj",
      "slug": "compodoc",
      "title": "Use compodoc for documentation",
      "optional": true,
      "content": "<h3>Problem</h3>\n<p>On boarding of new developers in your project can be quite difficult. Especially if the applications are getting bigger and bigger.</p>\n<p>And when the project is getting really big, even for developers that have been working on it for a long time, keeping an overview can become hard.</p>\n<h3>Solution</h3>\n<p>Documentation for our code is the solution to these problems. Of course, everyone knows that writing documentation is hard, boring and the documentation itself gets out of date quite quickly.</p>\n<p>We can however use compodoc to generate documentation from our code. This means that it doesn’t take any time to write and it can never get out of date as it is generated from the existing code at all times.</p>\n<h3>Resources</h3>\n<p><a href=\"https://compodoc.app/\">Compodoc</a></p>\n"
    },
    "V15M7": {
      "id": "V15M7",
      "slug": "prettier",
      "title": "Use prettier for code formatting",
      "optional": true,
      "content": "<h3>Problem</h3>\n<p>Whenever we write code, we want this code to be formatted in a standardised way. This poses two problems.</p>\n<ul>\n<li>We need to align everyone in the team to agree with the same standards.</li>\n<li>We need to get all of their IDE’s/editors aligned as well. This can be extremely difficult.</li>\n</ul>\n<h3>Solution</h3>\n<p>Prettier is an opinionated code formatter that can fix both of these problems. It imposes a standard way of formatting and it has a CLI that makes sure the formatting happens the same way on all environments. Adding Prettier and running it as a pre-commit hook will make sure only formatted code can be checked in.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://prettier.io/\">Prettier</a></li>\n<li><a href=\"https://github.com/schuchard/prettier-schematic\">Add prettier to angular CLI schematic</a></li>\n</ul>\n"
    },
    "Z2hzSxp": {
      "id": "Z2hzSxp",
      "slug": "avoid-using-any",
      "title": "Avoid using any",
      "content": "<h3>Problem</h3>\n<p>Typescript allows us to write code that is type checked. This provides huge benefits. It helps us during development with auto completion, it simplifies working with third party libraries, helps us to refactor our code, and much more. And all of this by adding types to our codes.</p>\n<p>If we start using the <code>any</code> keyword, are basically telling Typescript to ignore the following section, thus loosing all benefits.</p>\n<h3>Solution</h3>\n<p>Instead of using the any type, we should define proper types in our code. In the next example, we define a type for our variable.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> user: {name: <span class=\"hljs-built_in\">string</span>, password: <span class=\"hljs-built_in\">string</span>};\n</code></pre>\n<p>If we are using this type in multiple places, we can also extract it to a separate interface.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">interface</span> User {\n\tname: <span class=\"hljs-built_in\">string</span>;\n\tpassword: <span class=\"hljs-built_in\">string</span>;\n}\n</code></pre>\n<h4>3th party libraries</h4>\n<p>When working with 3th party libraries that are writtin in javascript, we don’t have types available. Luckily there is an initiative to create type definitions for those libraries. If it exists, you can find it by installing the type package via <code>yarn add --dev @types/${library-name}</code>.</p>\n<p>If this does not exist yet, you can create one yourself.</p>\n"
    },
    "23KPo0": {
      "id": "23KPo0",
      "slug": "define-interfaces-for-models",
      "title": "Define interfaces for models",
      "content": "<h3>Problem</h3>\n<p>Typescript helps us to create type safe code. When we let our application interface with some REST apis, we will get back data at runtime that is in a specific format. When we don’t define types in our code for the objects we expect to get back, we lose the benefit of typescript for data coming back from the client at compile time.</p>\n<h3>Solution</h3>\n<p>Defining an interface for every API we will interface gives us all the benefits typescript brings.</p>\n<p>For example, if you know a backend request will return an object with the properties ‘userName’ and ‘password’, which both are strings. Define the type like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> User {\n  userName: <span class=\"hljs-built_in\">string</span>;\n  password: <span class=\"hljs-built_in\">string</span>;\n}\n</code></pre>\n"
    },
    "12Aq23": {
      "id": "12Aq23",
      "slug": "define-types-at-the-non-typed-boundaries",
      "title": "Define types at the non typed boundaries",
      "content": "<h3>Problem</h3>\n<p>All our Javascript code is written in Typescript. This means that we can leverage types. Our code however interacts with different non typed boundaries such as the html layer (think of events) and backend requests. Interacting with these boundaries influences the type safety of our code.</p>\n<h3>Solution</h3>\n<p>When interacting with these boundaries, it is important to add the types so Typescript knows the structure of the object. By providing the type at the boundary, Typescript is able to infer it everywhere else that variable is being used.</p>\n<p>For example when working with custom events:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  template: <span class=\"hljs-string\">`&lt;some-other-component (someEvent)=\"someEventHandler($event)\"&gt;&lt;/some-other-component&gt;`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent {\n  someEventHandler(event: TypeForThisEvent) {\n    <span class=\"hljs-comment\">// ...</span>\n  }\n}\n</code></pre>\n<p><code>TypeForThisEvent</code> will make sure that the non typed html event is typed inside of our Typescript code.</p>\n"
    },
    "ZRBVWY": {
      "id": "ZRBVWY",
      "slug": "move-common-types-to-interfaces",
      "title": "Define interfaces for models",
      "content": "<h3>Problem</h3>\n<p>With typescript, we can easily add types to our code like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> user: {userName: <span class=\"hljs-built_in\">string</span>, password: <span class=\"hljs-built_in\">string</span>};\n</code></pre>\n<p>In this case, we defined the type of our user ‘inline’. While this is a valid option, it also means that it’s not reusable. We could define it in multiple places. The downside here is that, when it is updated, we have to update it everywhere.</p>\n<h3>Solution</h3>\n<p>Whenever a type is used in multiple places, it is best to move it to a separate interface.</p>\n<p>Here is an example:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> User {\n  userName: <span class=\"hljs-built_in\">string</span>;\n  password: <span class=\"hljs-built_in\">string</span>;\n}\n</code></pre>\n"
    },
    "ZEhkug": {
      "id": "ZEhkug",
      "slug": "use-type-inference",
      "title": "Use type inference",
      "content": "<h3>Problem</h3>\n<p>Typescript is really good at inferring the types in our code. Whenever it can do that, we don’t have to add the type ourselves.</p>\n<p>If we do add them everywhere, it doesn’t only take a lot of time, but it also means that we have to update them everywhere whenever anything changes.</p>\n<h3>Solution</h3>\n<p>Instead of defining the types, we can let typescript infer the types.</p>\n<p>So instead of doing this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> example: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">'typescript will infer the string type by default'</span>;\n</code></pre>\n<p>We omit the type as typescript can infer that as we assign it a string property.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> example = <span class=\"hljs-string\">'typescript will infer the string type by default'</span>;\n</code></pre>\n"
    }
  }
}